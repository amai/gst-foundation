~~
~~ Copyright 2016 Function1, Inc. All Rights Reserved.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~    http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.
~~

HOW-TO

	{{Build and Package the GSF Project}}

	{{Use Your Own Factory Implementation}}

	{{Use Your Own App Context Implementation}}

	{{Use Your Own Asset Type as a GST Property Asset}}
	
	{{Use Your Own NavService Implementation}}

	{{Make Your Own Beans / Objects Available for Injection}}
	
	{{Use Your Own NavigationNode Implementation}}
	
	{{Inject Your Own Beans / Objects Into a WCS 12c Controller}}	

Build and Package the GSF Project

	Building and packaging the GSF's components is very simple; just execute the package.sh shell script located in the project's root folder:

+--				
$ sh package.sh
+--

	This will:
	
		[[1]] Download all due MAVEN artifacts
	
		[[1]] Build the entire MAVEN project, including both CORE and LEGACY submodules / components.
	
		[[1]] Build the GSF website.
	
		[[1]] Package all of the above in 2 separate files: the GSF "KIT" and the GSF "SITE".
		
		[]
		
	The script is quite verbose; hence, it should be trivial understanding what it is doing and where you can pick up the output (files)
	
	In addition to the default behaviour, you also have the ability to invoke just one part of the whole packaging process:
	
		* <<"sh package.sh jar">>: this will download the artifacts and build the project (e.g. produce the JARs), but it won't generate the website, package it nor will it package the Kit.
		
		* <<"sh package.sh kit">>: this will package the GSF Kit for you, but it will not build the project for you (e.g. it won't re-compile the code)
		
		* <<"sh package.sh site">>: this will package the GSF Website for you, but it will not build the project nor package the GSF Kit for you.
		
		* <<"sh package.sh all">>: this is the default behaviour, i.e. it is <<equivalent to "sh package.sh">>.
		
		[]
		
	If you want MAVEN to include a timestamp on every line it outputs, make sure you configure MAVEN accordingly. You can find useful information {{{https://maven.apache.org/maven-logging.html} here}}.   

Use Your Own Factory Implementation

	* Implement your own custom factory.
	
		* Typically, you'll want to extend either <<tools.gsf.config.IcsObjectFactory>> or even <<tools.gsf.config.BaseFactory>>.
		
		* The only true requisite is that you implement the <<tools.gsf.config.Factory>> interface.
		
		* There are other factories you could either extend or reuse (for instance, SpringObjectFactory)
		
		[]
	
	* Register it:
	
		[[1]] Create a file named "gsf-factory".
		
		[[1]] Inside your "gsf-factory" file, specify the fully-qualified name of your custom factory class.
		
		[[1]] Package your "gsf-factory" file inside the "META-INF" folder of any JAR file to be deployed inside the WCS web app.
		
			[[a]] Typically, you'd package this inside either your own JAR file or the GSF's JAR file itself.
			
		[[1]] Deploy the JAR file containing your "gsf-factory" file inside the WCS web app.
			
		[]
		
	[]
		
Use Your Own App Context Implementation
    
	* Implement your own custom app context.
	
		* Typically, you'll want to extend <<tools.gsf.config.DefaultWebAppContext>> or even <<tools.gsf.config.WebAppContext>>.
		
		* The only true requisite is that you implement the <<tools.gsf.config.AppContext>> interface.
		
		[]
	
	* Register it:
	
		[[A]] ALTERNATIVE #1: via <<META-INF>>
	
			[[1]] Create a file named "gsf-contexts".
			
			[[1]] Inside your "gsf-contexts" file, specify the fully-qualified name of your custom factory class.
			
				[[a]] You can even specify a hierarchy of contexts (one per line), but that's extremely unusual and only intended for true GSF experts.
				
			[[1]] Package your "gsf-contexts" file inside the "META-INF" folder of any JAR file to be deployed inside the WCS web app.
			
				[[a]] Typically, you'd package this inside either your own JAR file or the GSF's JAR file itself.
				
			[[1]] Deploy the JAR file containing your "gsf-contexts" file inside the WCS web app.
				
			[]
		
		[[A]] ALTERNATIVE #2: via <<web.xml>>
		
			* If the WCS web app is getting deployed as a plain folder structure (a.k.a. "exploited" WAR file): 
			
				[[1]] Stop the WCS web app.
					
				[[1]] Add the context param to the WCS web app's web.xml called "gsf-contexts", whose value is the fully-qualified name of your custom App Context class:

+--				
(...)
<context-param>
	<param-name>gsf-contexts</param-name>
	<param-value>com.mycompany.gsf.MyCustomGSFAppContextImplementation</param-value>
</context-param>
(...)
+--
				
				[[1]] Restart the WCS web app.
					
				[]
				
			* If the WCS web app is getting deployed as a WAR file:			

				[[1]] Copy the WCS web app's WAR file onto a separate temporary folder (e.g. apart from both the app server's folder structure and WCS' install folder) 
				
				[[1]] Extract the contents of the copied WAR file.

				[[1]] Add a context-param to the WCS web app's web.xml called "gsf-contexts", whose value is the fully-qualified name of your custom App Context class:

+--				
(...)
<context-param>
	<param-name>gsf-contexts</param-name>
	<param-value>com.mycompany.gsf.MyCustomGSFAppContextImplementation</param-value>
</context-param>
(...)
+--
				
				[[1]] Repack the WCS web app's WAR, including the modified web.xml file (e.g. jar ...)
				
				[[1]] Stop the WCS web app.
				
				[[1]] Replace the existing WCS web app's WAR with the new, modified one.
					
				[[1]] Restart / Redeploy the WCS web app.

				[]
				
			[]
			
		[]
		
	[]
	
Use Your Own Asset Type as a GST Property Asset

	* Implement your own object factory from scratch.
	
	* Add to your custom object factory a Service Producer method (i.e. annotated with @ServiceProducer) which instantiates the new <<com.fatwire.gst.foundation.properties.AssetApiPropertyDao>>.
		
	* Example:
	
+--

@ServiceProducer(cache = true)
public PropertyDao createPropertyDao(final ICS ics) {
	Session session = SessionFactory.getSession(ics);
	AssetDataManager adm = (AssetDataManager) session.getManager(AssetDataManager.class.getName());
	SiteManager sm = (SiteManager) session.getManager(SiteManager.class.getName());
	String type = "MyCustomAssetType";
	String flexDefName = "MyCustomFlexDefName";
	String propNameAttr = "nameOfAttributeToGetThePropertyNameFrom"; \\ Typically "name"
	String propDescAttr = "nameOfAttributeToGetThePropertyDescriptionFrom"; \\ Typically "description"
	String propValueAttr = "nameOfAttributeToGetThePropertyValueFrom"; \\ Typically "value"
	return new AssetApiPropertyDao(adm, sm, type, flexDefName, propNameAttr, propDescAttr, propValueAttr, ics);
}

+--
		
	[]

Use Your Own NavService Implementation

	* Implement your own object factory.
	
	* Make your custom bean / object available by having a Service Producer method in your own object factory instantiate it:
		
		* In case you have <<extended>> IcsObjectFactory, you probably want to override the existing <<"createNavService">> method.
		
		* In case you have not extended IcsObjectFactory, you must add the due Service Producer method to your own implementation; for example: 
	
+--

@ServiceProducer(cache = true)
public NavService<AssetNode> createNavService(final ICS ics) {
    TemplateAssetAccess dao = getObject("templateAssetAccess", TemplateAssetAccess.class);
    return new MyCustomNavServiceImplementation(ics, dao);
}

+--
		
		[]
		
	[]
	

Make Your Own Beans / Objects Available for Injection
				
	See "Use a Custom Asset Type as a GST Property Asset" and "Implement (and Use) Your Own NavService Implementation" above.
	
	In general, all you need to do is implement your own object factory and make your custom bean available by adding the due Service Producer (annotated) method to it.

Use Your Own NavigationNode Implementation

	This one depends on what "using your own NavigationNode implementation" means to you:
	
	* If you literally want to use your own <<Node>> implementation, then doing so requires your implementing your own <<NavService>>, too.
	
		* You can either implement your own NavService from scratch or extend the existing ones (see <<SitePlanNavService>> or <<LightweightSitePlanNavService>>)
	
		* Plugging in your own NavService is simple (see above)
	
	* If you are using one of the OOTB NavService implementations and you just want each <<AssetNode>> to be pre-populated with additional data other than the asset's "name" and "template", then you just need to override the <<"populateNodeData">> method.
	
	[]
	
Inject Your Own Beans / Objects Into a WCS 12c Controller

	* Extend GSF's own <<tools.gsf.controller.InjectingController>> instead of WCS 12c's BaseController.
	
		We suggest you look at the source code of GSF's <<InjectingController.java>> for better understanding how GSF's injection and WCS' Controllers are being integrated.
				
	* <<A VERY IMPORTANT NOTE (WARNING) ON style="element" IN WCS 12c>>.
	
		WCS 12c will not invoke your Template's controller in case you invoke it using a render:calltemplate tag call with style="element".
		
		In such scenario, if your Template's code depended on its own Controller's logic (which is usually the case), it would break.
		
		Previous versions of the GSF defaulted to style="element" under certain conditions, in an attempt to intelligently set the call's style whenever you didn't set it explicitly.
		
		This did not occur in WCS 11.x and previous versions since Controllers were just introduced in WCS 12c.
		
		If you are using the <<GST/Dispatcher wrapper>>, <<GSF actions>> or any other LEGACY (hence deprecated) feature related to those two, be aware that combining those with the use of WCS 12c Controllers may yield erratic behaviour for the same reason.
		
		You can work around this by:
		
			[[1]] Making sure all Layout Templates ever invoked via the GST/Dispatcher (e.g. GSF actions) are set to "cached", hence preventing GSF's LEGACY CallTemplate Facade from automatically setting style="element" for you, OR
			
			[[1]] Avoiding the use of Layout Template which rely on Controllers attached to them in conjunction with GSF Actions and/or GST/Dispatcher.
			
			[]
			
		In addition to this, if you really need to use GSF Actions AND Controllers, here are some ideas to minimize chance of your CallTemplate calls breaking (DISCLAIMER: as per the above explanation, these may not cover you 100%):			
															
			[[A]] Adjust all of your calls to GSF-12 LEGACY's CallTemplate facade so to set "style" explicitly to something other than "element" whenever the called Template has a Controller attached to it.
			
			[[A]] Use GSF-12 CORE's (new) CallTemplate facade (instead of LEGACY's), which forces your explicitly setting "style" on each call, and make sure you set style to the appropriate value, as per the aforementioned considerations.

		From the above, you've probably figured out already that GSF-12 deals with the potential chaos this style-related behaviour could cause on pre-existing code you attempt migrating to WCS 12c's Controller-based paradigm simply by getting rid of the "legacy" intelligence.
		
		This implies there are now 2 CallTemplate facades:
		
			* The new one, which ships with the CORE artifact / JAR. In this one, style will NEVER be autocalculated for you. Either you set it explicitly - to the appropriate value - on each call or an Exception will be thrown, thus breaking your code.
			
			* The old one, which ships with the LEGACY artifact / JAR. This one has been left untouched, which means the style auto-selection intelligence is still there, with all that implies.
			
			[]		
		
	[]
